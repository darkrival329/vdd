---
# tasks/main.yml – robust pom.xml updater (no "track old" checks)
# -----------------------------------------------------------------------------
# 1. Guardrail: ensure required keys exist in dependency_config.json
# -----------------------------------------------------------------------------
- name: Validate required variables
  fail:
    msg: "{{ item }} is not defined in dependency_config.json"
  when: "{{ item }} is not defined"
  loop:
    - global.properties
    - global.dependencies
    - global.build_plugins
    - global.plugin_dependencies
    - global.release_version
    - global.release_date

# -----------------------------------------------------------------------------
# 2. Verify pom.xml exists in the working directory
# -----------------------------------------------------------------------------
- name: Assert pom.xml exists
  stat:
    path: "{{ pom_file }}"
  register: pom_stat

- name: Abort if pom.xml is missing
  fail:
    msg: "{{ pom_file }} does not exist"
  when: not pom_stat.stat.exists

# -----------------------------------------------------------------------------
# 3. Update <properties> values
# -----------------------------------------------------------------------------
- name: Update Maven properties from config
  community.general.xml:
    path: "{{ pom_file }}"
    xpath: "//pom:properties/pom:{{ item.key }}"
    namespaces:
      pom: "{{ pom_ns }}"
    value: "{{ item.value }}"
    pretty_print: true
  loop: "{{ global.properties | dict2items }}"
  when: global.properties is defined

# -----------------------------------------------------------------------------
# 4. Update top‑level <dependencies>
# -----------------------------------------------------------------------------
- name: Update dependency versions in pom.xml
  community.general.xml:
    path: "{{ pom_file }}"
    xpath: "//pom:dependency[pom:artifactId='{{ item.artifactId }}']/pom:version"
    namespaces:
      pom: "{{ pom_ns }}"
    value: "{{ item.version }}"
    pretty_print: true
  loop: "{{ global.dependencies }}"
  when:
    - global.dependencies is defined
    - item.artifactId is defined
    - item.version is defined
  ignore_errors: true

# -----------------------------------------------------------------------------
# 5. Update top‑level <build><plugins>
# -----------------------------------------------------------------------------
- name: Update build plugin versions in pom.xml
  community.general.xml:
    path: "{{ pom_file }}"
    xpath: "//pom:plugin[pom:artifactId='{{ item.artifactId }}']/pom:version"
    namespaces:
      pom: "{{ pom_ns }}"
    value: "{{ item.version }}"
    pretty_print: true
  loop: "{{ global.build_plugins }}"
  when:
    - global.build_plugins is defined
    - item.artifactId is defined
    - item.version is defined

# -----------------------------------------------------------------------------
# 6. Update <plugin><dependencies> nested inside plugins
# -----------------------------------------------------------------------------
- name: Update plugin‑scoped dependency versions
  community.general.xml:
    path: "{{ pom_file }}"
    xpath: "//pom:plugin[pom:artifactId='{{ item.pluginArtifactId }}']//pom:dependency[pom:artifactId='{{ item.artifactId }}']/pom:version"
    namespaces:
      pom: "{{ pom_ns }}"
    value: "{{ item.version }}"
    pretty_print: true
  loop: "{{ global.plugin_dependencies }}"
  when:
    - global.plugin_dependencies is defined
    - item.pluginArtifactId is defined
    - item.artifactId is defined
    - item.version is defined

# -----------------------------------------------------------------------------
# 7. Generate / update CHANGELOG
# -----------------------------------------------------------------------------
- name: Set default changelog path
  set_fact:
    changelog_path: "{{ changelog_path | default('CHANGELOG.md') }}"

- name: Check if changelog exists
  stat:
    path: "{{ changelog_path }}"
  register: changelog_stat

- name: Ensure changelog directory exists
  file:
    path: "{{ changelog_path | dirname }}"
    state: directory
  when: changelog_path | dirname != '.' and changelog_path | dirname != ''

- name: Read existing changelog content
  slurp:
    path: "{{ changelog_path }}"
  register: changelog_content
  when: changelog_stat.stat.exists

- name: Generate new changelog entry
  template:
    src: changelog_entry.md.j2
    dest: "{{ playbook_dir }}/.changelog_entry.md"
  register: new_entry_file
  when:
    - global.release_version is defined
    - global.release_date is defined
    - not changelog_stat.stat.exists or 
      (changelog_stat.stat.exists and 
       global.release_version not in changelog_content.content | b64decode)

- name: Read new changelog entry
  slurp:
    path: "{{ playbook_dir }}/.changelog_entry.md"
  register: new_entry_content
  when: new_entry_file is changed

- name: Set new entry fact
  set_fact:
    new_entry: "{{ new_entry_content.content | b64decode }}"
  when: new_entry_file is changed

- name: Debug new changelog entry
  debug:
    msg: "{{ new_entry }}"
  when: debug_mode | bool and new_entry is defined

- name: Render changelog
  template:
    src: changelog.md.j2
    dest: "{{ changelog_path }}"
    force: yes
  when:
    - global.release_version is defined
    - global.release_date is defined

- name: Clean up temporary changelog entry
  file:
    path: "{{ playbook_dir }}/.changelog_entry.md"
    state: absent
  when: new_entry_file is changed

# -----------------------------------------------------------------------------
# End of tasks
...
